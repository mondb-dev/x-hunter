#!/usr/bin/env node
/**
 * runner/generate_checkpoint.js — produce checkpoints/checkpoint_N.md every 3 days
 *
 * Reads:  state/checkpoint_state.json (tracking last checkpoint date + count)
 *         state/ontology.json, state/belief_state.json
 *         daily/belief_report_*.md (last 3 available)
 * Writes: checkpoints/checkpoint_N.md
 *         checkpoints/latest.md (always overwritten with the same content)
 *         state/checkpoint_state.json (updated)
 *
 * Called daily from run.sh. Skips if fewer than 3 days have elapsed since last checkpoint.
 * Non-fatal: exits 0 on any error after logging.
 */

"use strict";

const fs   = require("fs");
const path = require("path");

const ROOT             = path.resolve(__dirname, "..");
const CHECKPOINTS_DIR  = path.join(ROOT, "checkpoints");
const DAILY_DIR        = path.join(ROOT, "daily");
const ONTO             = path.join(ROOT, "state", "ontology.json");
const BELIEF           = path.join(ROOT, "state", "belief_state.json");
const CHECKPOINT_STATE = path.join(ROOT, "state", "checkpoint_state.json");

const CHECKPOINT_INTERVAL_DAYS = 3;

const today = new Date().toISOString().slice(0, 10); // YYYY-MM-DD

function loadJson(p) {
  try { return JSON.parse(fs.readFileSync(p, "utf-8")); } catch { return null; }
}

function daysBetween(dateA, dateB) {
  const msA = new Date(dateA).getTime();
  const msB = new Date(dateB).getTime();
  return Math.round(Math.abs(msB - msA) / 86_400_000);
}

(function main() {
  try {
    // Load checkpoint state
    let cpState = loadJson(CHECKPOINT_STATE) || { last_checkpoint_date: null, checkpoint_count: 0 };

    // Check if enough days have elapsed
    if (cpState.last_checkpoint_date) {
      const elapsed = daysBetween(cpState.last_checkpoint_date, today);
      if (elapsed < CHECKPOINT_INTERVAL_DAYS) {
        console.log(
          `[checkpoint] ${elapsed} day(s) since last checkpoint — ` +
          `next in ${CHECKPOINT_INTERVAL_DAYS - elapsed} day(s), skipping`
        );
        return;
      }
    }

    // Gather recent daily reports (last 3)
    let recentReports = "";
    if (fs.existsSync(DAILY_DIR)) {
      const reportFiles = fs.readdirSync(DAILY_DIR)
        .filter(f => f.startsWith("belief_report_") && f.endsWith(".md"))
        .sort()
        .slice(-3);
      recentReports = reportFiles.map(f => {
        const content = fs.readFileSync(path.join(DAILY_DIR, f), "utf-8");
        // Extract just the summary sections (skip heavy full-ontology dump)
        const lines = content.split("\n");
        const summaryEnd = lines.findIndex((l, i) => i > 5 && l.startsWith("## Full ontology"));
        const snippet = lines.slice(0, summaryEnd > 0 ? summaryEnd : 30).join("\n");
        return `### From ${f.replace("belief_report_", "").replace(".md", "")}\n${snippet}`;
      }).join("\n\n---\n\n");
    }

    // Load current belief state
    const onto   = loadJson(ONTO);
    const belief = loadJson(BELIEF);
    const axes   = onto?.axes || [];
    const activeAxes = (belief?.axes || []).filter(a => (a.confidence || 0) > 0.1);

    // Determine checkpoint number
    const n = (cpState.checkpoint_count || 0) + 1;

    if (!fs.existsSync(CHECKPOINTS_DIR)) fs.mkdirSync(CHECKPOINTS_DIR, { recursive: true });

    // Build checkpoint content
    const highConf = activeAxes
      .sort((a, b) => (b.confidence || 0) - (a.confidence || 0))
      .slice(0, 5)
      .map(a => `- \`${a.id}\`: conf ${((a.confidence || 0) * 100).toFixed(0)}%, score ${(a.score || 0).toFixed(3)}`)
      .join("\n") || "- (none with confidence > 0.10 yet)";

    const allAxesSummary = axes.map(a => {
      const ev    = (a.evidence_log || []).length;
      const conf  = ((a.confidence || 0) * 100).toFixed(0);
      const score = (a.score || 0).toFixed(3);
      return `| ${a.label} | ${score} | ${conf}% | ${ev} |`;
    }).join("\n") || "| (none) | — | — | — |";

    const checkpoint = `---
date: "${today}"
title: "Checkpoint ${n} — ${today}"
checkpoint: ${n}
---

# Checkpoint ${n} — ${today}

**Generated:** ${new Date().toISOString()}
**Cycle:** Every ${CHECKPOINT_INTERVAL_DAYS} days
**Previous checkpoint:** ${cpState.last_checkpoint_date || "(none)"}

---

## Belief state summary

Total axes: **${axes.length}**
Axes with confidence > 10%: **${activeAxes.length}**

### Highest-confidence axes

${highConf}

---

## Full ontology at this checkpoint

| Axis label | Score | Confidence | Evidence entries |
|---|---|---|---|
${allAxesSummary}

---

## Recent daily reports

${recentReports || "(no daily reports yet)"}

---

*This checkpoint was auto-generated by generate_checkpoint.js.*
*Beliefs accumulate across all cycles — only the observation phase resets per cycle.*
`;

    const cpPath     = path.join(CHECKPOINTS_DIR, `checkpoint_${n}.md`);
    const latestPath = path.join(CHECKPOINTS_DIR, "latest.md");

    fs.writeFileSync(cpPath,     checkpoint, "utf-8");
    fs.writeFileSync(latestPath, checkpoint, "utf-8");

    // Update state
    cpState.last_checkpoint_date = today;
    cpState.checkpoint_count     = n;
    fs.writeFileSync(CHECKPOINT_STATE, JSON.stringify(cpState, null, 2), "utf-8");

    console.log(`[checkpoint] written: checkpoints/checkpoint_${n}.md + latest.md`);
  } catch (err) {
    console.error(`[checkpoint] failed: ${err.message}`);
    process.exit(0); // non-fatal
  }
})();
